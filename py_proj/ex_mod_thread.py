# -*- coding: utf-8 -*-
__author__ = 'admin'

"""
#Многопоточность
#thread - Модуль для создания нескольких потоков и управление ими
import thread #Считается устаревшим
import time
#В случае ошибок генерируются исключения этого класса
print thread.error

#Объект типа для объектов блокировки
print thread.LockType

#Запуск потока с вызовом функции
#Запрос на создание блокировки
a_lock = thread.allocate_lock()

#Кортеж параметров для потока
kort=('el1','элемент2')
#функция потока
def fun_thr(*par1):
    with a_lock:
        print "Заблокировано на 3 секунды, второй поток пасёт и ждет"
        time.sleep(3)
    for i in xrange(3):
        print par1[1],"\n",'id_thread=',thread.get_ident() #получить id потока
        time.sleep(1)
        #thread.exit_thread() #Выход из потока по исключению
    with a_lock:
        print "Заблокировано на 3 секунды, второй поток пасёт и ждет"
        time.sleep(5)
    thread.exit()
#функция потока
def fun_thr1(*par1):
    for i in xrange(20):
        if not a_lock.locked():#Проверка если не поток заблокирован работать
            print 'Поток 2 разблокирован, можно работать'
        time.sleep(1)
    thread.exit()
thread.start_new_thread(fun_thr,kort) #,dict)
thread.start_new_thread(fun_thr1,kort)


#a_lock.release_lock()- почему то вызывает ошибку

for i in xrange(10):
    print "main\n"
    time.sleep(1)
"""




#threading - модуль многопоточности рекомендованный на классах
#from threading import *

#Количество активных потоков
#print threading.activeCount()
"""
Создает и возвращает объект, реализующий условие.
Этот объект позволяет одному или нескольким потокам
ожидать уведомления от другого потока.
Если задан аргумент lock Condition(lock)
то он должен быть объектом, возвращаемым функцией Lock()
или RLock(). Этот объект будет использован для блокировки.
по умолчанию создается новый объект с помощью функции RLock()
"""
#Condition()
#threading.Condition()

#Возвращает объект текущего потока
#print threading.currentThread()

#Возвращает список объектов, активных потоков, созданных с помощью модуля
#threading. Всписок входят объекты текущего и основного потока, но без
#Ещё не начавших работать и без завершенных
#print threading.enumerate()

#Создает и возвращает объект, реализующий событие.
#Этот объект позволяет потоку ожидать наступления (установки в другом объексте)
#события
#ev=threading.Event()

#Создает и возвращает объект, реализующий блокировку.
#В текущих реализациях является псевдонимом для функции thread.allocate_lock()
#alock=threading.Lock()

#Создает и возвращает объект, реализующий блокировку.
#В отличие от объекта, возвращаемого функцией Lock(), допускает
#повторный захват в том же потоке.
#Объект должен быть освобожден тем же потоком ровно столько раз,
#сколько он был захвачен.
#rlock=threading.RLock()

#Создает и возвращает объект, реализующий семафор.
#Семафор может быть захвачен не более count раз (по дефолту 1).
#При последующих попытках захватить семафор ожидает, пока
#другой поток не освободит его.
#sem=threading.Semaphore()

#Создающая поток функция-конструктор, принимает несколько именованных
#аргументов. Действия выполняемые при запуске потока, могут быть установлены
#аргументом target - должен быть объектом поддерживающим вызов
#вроде __callable__. Этот объект вызывается из метода run() c
#позиционными и именованными аргументами, заданным именами
#args и kwargs (по дефлоту пустые кортеж и словарь). Аргумент name
#указывает имя потока, по умолчанию Thread-N где N-десятичное представление
#небольшого целого числа.
#threading.Thread(group,target,name,args,kwargs,verbose)


#При вызове без аргументов захватывает (блокирует объект), дождавшись,
#если это необходимо, его освобождения другим потокам (возвращает None).
#Если задан аргумент waitflag (целое число), поведение функции зависит от его
#значения: 1-функция ожидает освобождения объекта другим потокам
#(так же, как и с опущенным аргументом), 0 (и другие значения) - объект
#захватывается только, если это может быть сделано немедленно. При наличии
#аргумента функция возвращает 1, если захват объекта прошел успешно,
#в противном случае возвращает 0.
#rlock=threading.RLock()
#rlock.acquire(1)

#Освобождает объект. Объект должен быть захвачен ранее.
#Если метод применяется к объекту, возвращаемому функцией RLock(),
#объект должен быть захвачен этим же потоком.
#rlock.release()

#В то время как объекты, возвращаемые функцией Lock(), реализуют примитивную
#блокировку (объект может быть захвачен один раз), для объектов, возвращаемых
#функцией RLock(), методом acquire() может быть вызван многократно одним потоком
#для того, чтобы объект мог быть захвачен другим потоком,
#необходимо ровно столько же раз вызвать метод release()

#Условия Condition
#Объекты, возвращаемые функцией Condition() всегда ассоциированы с объктом,
#реализующем блокировку. Такой объект может быть указан в качестве
#аргумента при инициализации или, по умолчанию, будет создан конструктором.

#Объект, представляющий условие, имеет методы acquire() и release(),
#которые вызывают соответствующие методы ассоциированного объекта,
#реализующего блокировку. Он также имееет методы wait(), notify() и notifyAll(),
#которые должны вызываться только после того, как будет вызван метод acquire().
#При вызове wait() объект - условие освобождает ассоциированный объект и
#блокирует выполнение до тех пор, пока из другого потока не будет вызван
#метод notify() или notifyAll(). После пробуждения метод снова захватывает
#ассоциированный объект. Вы можете указать максимальное время ожидания.
#Методы notify() и notifyAll() не освобождают ассоциированный объект,
#реализующий блокировку. Таким образом, поток или потоки, вызвавшие метод
#wait(), будут пробуждены только после того как поток, вызвавший notify()
#или notifyAll() окончательно освободит ассоциированный объект. Можно указать
#максимальное время ожидания.

#Методы notify() и notifyAll() не освобождают ассоциированный объект,
#реализующий блокировку. Таким образом, как поток или птооки, вызвавшие метод
#wait(), будут пробуждены только после того, как поток, вызвавший notify() или
#notifyAll() окончательно освободит ассоциированный объект.

#Пример производства и потребления потоков. make_tr() производит объект.
#get_tr() потребляет, tr_isavaible() возвращает истину, если есть в
#наличии произведенные (но ещё не употребленные) объекты.
#Тогда следующие фрагменты кода могут быть использованы в потоках
#производителя и потребителя соответственно.

#Производим один объект
"""
cv=threading.Condition()
cv.acquire()
make_tr()
cv.notify()
cv.release()

#Потребляем один объект
cv.acquire()
while not tr_isavaible():
    cv.wait()
get_tr()
cv.release()
"""

"""
acquire ([...]) release()
Вызывают одноименные методы ассоциированного объекта, реализующего блоки¬ровку.

wait ([timeout])
Освобождает ассоциированный объект, реализующий блокировку, ожидает, пока другим потоком не будет вызван метод notify() или notifyAll() , и сно¬ва захватывает ассоциированный объект. Если задан и не равен None аргумент timeout (вещественное число), он указывает максимальное время ожидания в секундах. По умолчанию время ожидания не ограничено.
Если для блокировки используется объект, возвращаемый функцией RLock() , этот метод использует его детали реализации для полного освобождения и вос¬становления уровня захвата объекта.

notify()
Пробуждает один поток, ожидающий выполнения условия, если таковой имеется.

notifyAll()
Пробуждает все потоки, ожидающие выполнения условия.


22.2.3	Семафоры

Объекты, возвращаемые функцией Semaphore() имеют такой же набор методов, как и объекты, реализующие блокировку (см. раздел 22.2.1). Семафор управляет внутренним счетчиком, который уменьшается при каждом вызове метода acquire() и увеличива¬ется при каждом вызове метода release() . Начальное значение счетчика определяет аргумент, переданный конструктору Semaphore() . Значение счетчика не может стать меньше нуля: вызов метода acquire() при значении счетчика равным нулю блокирует выполнение до тех пор, пока значение не увеличится, то есть пока другой поток не вызовет метод release() .


22.2.4	События

Объекты, возвращаемые функцией Event() реализуют простейший механизм взаимо¬действия потоков: один поток подает сигнал о возникновении события и один или более потоков ожидают его. Объект-событие имеет внутренний флаг. Если этот флаг являет¬ся истиной, событие считается наступившим. Изначально (при создании объекта) флаг является ложью.


isSet()
Возвращает 1, если событие наступило (внутренний флаг является истиной).
set()
Устанавливает наступление события (внутренний флаг становится истинным). Все потоки, ожидающие события, пробуждаются.

clear()
Отменяет наступление события (внутренний флаг становится ложным). wait( [timeout])
Ожидает наступления события, то есть, если внутренний флаг является ложью, блокирует выполнение потока до тех пор, пока другой поток не вызовет метод set(). Если задан и не равен None аргумент timeout (вещественное число), он указывает максимальное время ожидания в секундах. По умолчанию время ожидания не ограничено.

22.2.5   Объекты, представляющие потоки

Экземпляры класса Thread представляют действия, выполняемые в отдельном потоке. Существует два способа определить эти действия: передача объекта, поддерживающего вызов, в качестве аргумента с именем target или переопределение метода run() в производных классах. В производных классах не следует переопределять другие методы, за исключением, возможно, конструктора. Если Вы переопределяете конструктор, не
забудьте вызвать конструктор дочернего класса (Thread.	init	()) до того, как
Вы будете что-либо делать с потоком.
После создания объекта, представляющего поток, Вы можете запустить его с по¬мощью метода start() . После запуска поток считается активным до тех пор, пока не закончится выполнение метода run() .
Каждый поток, реализованный с помощью Thread или производного от него клас¬са имеет имя. Имя может быть задано при инициализации или с помощью метода setName() и извлечено с помощью метода getName() .
Поток может "присоединиться" к другому потоку, вызвав метод join() объекта, представляющего этот поток. При этом выполнение потока, вызвавшего метод join() приостанавливается до тех пор, пока не завершится выполнение потока, к объекту ко¬торого был применен метод.
Поток может быть помечен как фоновый (daemon). Выполнение всей программы будет завершено только после того, как активными останутся только фоновые потоки. Начальное значение наследуется от текущего потока. Этот флаг может быть изменен с помощью метода setDaemon() и извлечен с помощью метода getDaemon().
Существует также объект, соответствующий основному потоку. Основной поток не является фоновым. Возможно также создание объектов, соответствующих "посто¬ронним" потокам, то есть потокам, созданным без помощи модуля threading. Такие объекты имеют ограниченную функциональность. Они всегда считаются активными, фо¬новыми и к ним нельзя присоединиться с помощью метода join() .


start()
Запускает выполнение задачи (метод run() объекта) в отдельном потоке. Этот метод может быть вызван не более одного раза.

run()
Этот метод представляет задачу, которая должна быть выполнена в отдельном потоке. Вы можете переопределить этот метод в производном классе. Стандартный метод run() вызывает функцию, указанную при инициализации объекта (аргумент с именем target).

join ([timeout])
Этот метод приостанавливает работу текущего потока (который вызвал метод) до окончания выполнения потока, к объекту которого метод применяется. Если задан и не равен None аргумент timeout (вещественное число), он указывает макси-

мальное время в секундах ожидания завершения работы потока. По умолчанию (и если аргумент timeout равен None) время ожидания не ограничено.
К одному потоку можно присоединиться несколько раз. Поток не может присоеди¬ниться к самому себе, так как это привело бы к (мертвой) блокировке самого себя. К потоку нельзя присоединиться до того, как он будет запущен.

getName ()
Возвращает имя потока.
setName( name)
Устанавливает имя потока. Имя потока является строкой, которая может быть использована для его идентификации. Несколько потоков могут иметь одинаковое имя. Начальное имя устанавливается конструктором.

isAlive ()
Возвращает 1 , если поток активен. Поток считается активным с момента вызова метода start() и до завершения выполнения задачи (метода run()).
isDaemon()
Возвращает значение внутреннего флага, который является истиной, если поток выполняется в фоновом режиме.

setDaemon( daemonic)
Устанавливает значение внутреннего флага, определяющего, в каком режиме вы¬полняется поток, равным daemonic: если флаг является истиной, поток будет выполняться в фоновом режиме. Этот метод должен вызываться до запуска пото¬ка. Начальное значение наследуется от потока, создавшего данный поток.
Работа всей программы может быть завершена только после завершения работы всех нефоновых потоков.



22.3   Queue — синхронизированные очереди


Модуль Queue определяет класс, реализующий очередь (FIFO), доступ к которой может осуществляться из нескольких потоков. Доступность этого модуля зависит от наличия модуля thread.

Queue(maxsize)
Создает и возвращает объект-очередь. Аргумент maxsize (целое число) определя¬ет максимальное количество элементов, которое можно поместить в очередь. По умолчанию, а также если maxsize меньше или равен нулю, размер очереди не ограничен.

Empty
Исключения этого класса генерируются при попытке извлечь из пустой или за¬блокированной очереди элемент с помощью метода get_nowait() (или get() с аргументом block равным нулю).

Full
Исключения этого класса генерируются при попытке добавить в полную или за¬блокированную очередь элемент с помощью метода put_nowait() (или put() с аргументом block равным нулю).


Экземпляры класса Queue имеют следующие методы:


qsize()
Возвращает количество элементов в очереди (в момент вызова метода). empty()
Возвращает 1, если очередь (в момент вызова метода) пуста, иначе возвращает 0.

full()
Возвращает 1, если очередь (в момент вызова метода) содержит максимальное количество элементов, иначе возвращает 0 .
put (item [,  block])
Добавляет элемент в очередь. Если аргумент block опущен или является истиной, выполнение потока при необходимости приостанавливается до тех пор, пока в оче¬реди не появится свободное место. Если аргумент block является ложью, элемент добавляется в очередь только, если это можно сделать немедленно, в противном случае генерируется исключение Full.

put_nowait( item)
Эквивалентно вызову put(item,  0).
get( [block])
Извлекает (удаляет) элемент из очереди и возвращает его. Если аргумент block опущен или является истиной, выполнение потока при необходимости приостанав¬ливается до тех пор, пока в очереди не появится элемент. Если аргумент block является ложью, элемент извлекается из очереди только, если это можно сделать немедленно, в противном случае генерируется исключение Empty.

get_nowait()
Эквивалентно вызову get(0) .


Не следует полагаться на значения, возвращаемые методами qsize(), empty() и full() : к моменту их получения ситуация может уже измениться.


"""


"""
import threading

class MyClass:
    def __init__(self):
         self.lock = threading.Lock()

    def critical_function(self):
        self.lock.acquire() # заполучить лок
        for i in xrange(10):
            print "thr1"
            time.sleep(3)
        #do_something_important() # этот код гарантированно не будет прерван каким либо другим потоком
        self.lock.release() # освободить лок

class MyThread(threading.Thread):
    def run(self):
        self.myclass = MyClass()
        while 1:
            for i in xrange(10):
                print "thr2"
                time.sleep(3)
            #do_something()
            self.myclass.critical_function()

thread1 = MyThread()
thread2 = MyThread()

thread1.start()
thread2.start()
"""



#Мои примеры потоков
import threading
import time

#Есть два способа создания потоков, через target или
#через переопределение класса threading.Thread

#Пример: через переопределение класса threading.Thread
#Поток выполняется пока работает run()
class MyThread(threading.Thread):
    def __init__(self):
        self.bStop=0
        self.count=0
        threading.Thread.__init__(self)
    def __del__(self):
        print "del"
    def run(self):
        while self.bStop<1:
        #while self.count<5:
            self.count+=1
            print 'self.count=',self.count
            time.sleep(1)
thr=MyThread()
thr.start()
#Основной поток пока не завершается чтоб поток не завершился
time.sleep(6)
#завершить run()
thr.bStop=1
del thr
time.sleep(1)






#Пример: через переопределение класса threading.Thread
#Поток выполняется пока работает run()
#Управление потоком через общую переменную
bStop=0
def run1():
    while  bStop<1:
        time.sleep(1)
        print "Внутри потока"

thr=threading.Thread(None,run1,"MyThread1")
thr.start()
time.sleep(3)

if thr.isAlive():
    print 'thr.isAlive'
else:
    print 'dead'
bStop=1
#Подождать пока поток сдохнет
while thr.isAlive():
    pass
if thr.isAlive():
    print 'thr.isAlive\n'
else:
    print 'dead\n'
print "эт конец"





#Ещё простой пример

import threading
import time

def proc(n):
    print "Поток", n

p1 = threading.Thread(target=proc, name="t1", args=["1"])
p2 = threading.Thread(target=proc, name="t2", args=["2"])
p1.start()
p2.start()

#Пример таймера
#threading.Timer(interval, function, args=[], kwargs={})
def hello(*par):
    while a<1:
        print "Hello, world!",par[0]
        time.sleep(0.5)
    print "end thread"
a=0
t = threading.Timer(1.0, hello,[a])
t.start()
time.sleep(3)
a=1


#Пример поочередного засыпания
import thread
count=0
def myfunction(string,sleeptime,count,lock,*args):
    while count<2:
	#entering critical section
        lock.acquire()
        print string," Now Sleeping after Lock acquired for ",sleeptime
        time.sleep(sleeptime)
        print string," Now releasing lock and then sleeping again"
        lock.release()
	#exiting critical section
        time.sleep(sleeptime) # why?
        count=count+1
#Похоже лочиться основной поток
if __name__=="__main__":
    lock=thread.allocate_lock()
thread.start_new_thread(myfunction,("Thread No:1",2,count,lock))
thread.start_new_thread(myfunction,("Thread No:2",2,count,lock))

time.sleep(5)
print "end main"
    #while 1:pass
"""





"""
#Пример синхронизации потоков с блокировками
print "Condition start"
#Let us profile code which uses threads
import thread
import time
from threading import *
count=0
class itemQ:

    def __init__(self):
        self.count=0

    def produce(self,num=1):
        self.count+=num

    def consume(self):
        if self.count: self.count-=1

    def isEmpty(self):
        return not self.count


class Producer(Thread):

    def __init__(self,condition,itemq,sleeptime=1):
        Thread.__init__(self)
        self.cond=condition
        self.itemq=itemq
        self.sleeptime=sleeptime

    def run(self):
        cond=self.cond
        itemq=self.itemq

        while 1 :

            cond.acquire() #acquire the lock
            print currentThread(),"Produced One Item"
            itemq.produce()
            cond.notifyAll()
            cond.release()

            time.sleep(self.sleeptime)


class Consumer(Thread):

    def __init__(self,condition,itemq,sleeptime=2):
        Thread.__init__(self)
        self.cond=condition
        self.itemq=itemq
        self.sleeptime=sleeptime

    def run(self):
        cond=self.cond
        itemq=self.itemq

        while 1:
            time.sleep(self.sleeptime)

            cond.acquire() #acquire the lock

            while itemq.isEmpty():
                cond.wait()

            itemq.consume()
            print currentThread(),"Consumed One Item"
            cond.release()




if __name__=="__main__":

    q=itemQ()

    cond=Condition()

    pro=Producer(cond,q)
    cons1=Consumer(cond,q)
    cons2=Consumer(cond,q)

    pro.start()
    cons1.start()
    cons2.start()
    #while 1: pass
time.sleep(5)




#Пример синхронизации потоков с Condition
#без сабклассинга более короткий
#Один поток блокирует остальные пишет - разблокирует
#Второй потток блокирует, читает, разблокирует
import threading
import thread
import random
import time
count=0
#Хитрость в том что список tuple попадаемый в функцию менять нельзя
#Но если первый элемента тупла ссылается на массив то элементы
#массива менять можно!
var1=[0]
def prod(string,count,cond,*var1):
    while count<5:
        cond.acquire()
        var1[0][0]=int(random.random()*10)
        print "Произведен элемент var1=",var1[0][0]
        cond.notifyAll()
        cond.release()
        time.sleep(0.5)
        count=count+1

def consume(string,count,cond,*var1):
    while count<5:
        cond.acquire()
        print "Потреблён",string,"элемент var1=",var1[0][0]
        cond.notifyAll()
        cond.release()
        time.sleep(0.5)
        count=count+1

cond=threading.Condition()

#Можно через threading.Thread
#Можно через thread.start_new_thread
p1 = threading.Thread(target=prod, name="t1", args=["Thread No:1",count,cond,var1])
p2 = threading.Thread(target=consume, name="t2", args=["Thread No:2",count,cond,var1])
p3 = threading.Thread(target=consume, name="t3", args=["Thread No:3",count,cond,var1])
p1.start()
p2.start()
p3.start()

# thread.start_new_thread(prod,("Thread No:1",count,cond,var1))
# thread.start_new_thread(consume,("Thread No:2",count,cond,var1))
# thread.start_new_thread(consume,("Thread No:3",count,cond,var1))

time.sleep(5)
print "end main"
    #while 1:pass




