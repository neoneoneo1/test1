# -*- coding: utf-8 -*-
__author__ = 'admin'
#re -Модуль регулярных выражений
#Необходимы необрабатываемые строковые последовательности
#Пример r"\n" даст 2 символа \  и n
print r"abc\nefg"
print R"abc\nefg"
print "abc\nefg"
"""
. -     любой символ, кроме новой строки
        если задан флаг DOTALL то
        любой символ вообще
^ -     по умолчанию начало строки.
        Если задан флаг MULTILINE,
        также удовлетворяет путой строке после символа новой строки
$ -     Удовлетворяет конце строки
        Если задан флаг MULTILINE,
        также удовлетворяет пустой строке перед символом новой строки
atom* - Удовлетворяет наибольшему возможному количеству
        (0 или более) фрагментов строки, удовлетворяющих выражению atom
        ab* удовлетворяют строки 'a', 'ab', 'abb' и т д
atom+ - Удовлетворяет наибольшему возможному количеству
        (1 или более) фрагментов строки, удовлетворяющих выражению atom
        ab+ удовлетворяют строки 'ab', 'abb' и т д но не 'a'
atom? - Удовлетворяет наибольшему возможному количеству (0 или 1)
        фрагментов строки, удовлетворяющих выражению atom
        Например выражению ab? удовлетворяют строки 'a' и 'ab'
{m,[n]}-Количество символов от m до n, если n опущено то считается бесконечным
atom*? -Удовлетворяет наименьшему возможному количеству (0 или более)
        фрагментов строки. '<.*>' удовлетворяет всей строке <H1>title</H1>
        <.*?> удовлетворяет только '<H1>'
atom+?- Удовлетворяет наименьшему возможному количеству (1 или более)
        фрагментов строки, удовлетворяющих выражению atom
atom??- Удовлетворяет наименьшему возможному количеству (0 или 1)
        фрагментов строки, удовлетворяющих выражению atom
{m,[n]}? Удовлетворяет наименьшему возможному количеству (от m до n)
        фрагментов строки.
[chars]-Множество символов [ab?] - удовлетворяют 'a','b','?'
        Если символ не буква или цифра то его надо поставить первым или
        поставить перед ним \, например:
        '[]]' или r'[]\-]'
        Символ ^ в множестве не должен идти первым, и должен быть единственным
        в множестве или записанным как \^
[^chars]Все символы не входящие во множество.
expr|expr - или
(expr) -Неделимое выражение, образует группу, фрагмент строки полученной
        через группу может быть извлечен потом или использован в этой же
        регулярке как r'\number'
(?options) - Задает опции всей регулярке
        i-IGNORECASE
        L - LOCALE
        m - MULTILINE
        s - DOTALL
        u - UNICODE
        t - TEMPLATE
        x - VERBOSE
        Можно просто передать флаги функции compile
(?:expr)Делает выражение неделимым но не образует группы
(?P<name>expr)- Работает аналогично записи (expr) но создает именованную группу
                с именем name
                Именованные группы так же, как и обычные, нумеруются и
                доступны через запись r'\number'

(?P=name)   Удовлетворяет тексту, который ранее удовлетворил выражению,
            указанному в группе с именем name
(?#comment) Комментарий, игнорируются.
(?=expr) -  Удовлетворяет пустой строке, но только если за ней следует текст
            удовлетворящий выражению expr. Например, выражению
            'Александр (?=Пушкин)' удовлетворяет фрагмент
            'Александр Пушкин'
(?!expr) -  Удовлетворяет пустой строке, но только если за ней следует текст,
            который не удовлетворяет выражению expr. Например выражению
            'Александр (?!=Пушкин)' удовлетворяет фрагмент удовлетворяет фрагмент
            'Александр' из строки 'Александр Сергеевич Пушкин'
(?<=expr) - Удовлетворяет пустой строке, но только если перед ней следует текст,
            который удовлетворяет выражению expr. Например, выражению
            '(?<=abc)def' удовлетворяет фрагмент 'def' строки 'abcdef'
            Выражение expr должно всегда удовлетворять строке одной длины.
            Например:
            Можно использовать 'abc' или 'a|b', но не 'a*'
            С версии питона 2.0 можно
(?<!expr)   Удовлетворяет пустой строке, но только если перед ней следует текст,
            который не удовлетворяет выражению expr.
\nember     Удовлетворяет содержимому группы с номером number.
            Группы нумеруются с 1. Например выражению r'(.+) \1'
            удовлетворяют строки 'the the' или '55 55', но не удовлетворяет
            строка 'the end'
            Эта последовательность может быть использована для ссылок на группы
            с номерами от 1 до 99. Если nember начинается с 0 то запись в
            в восьмеричном формате - \0ххх.
            Если храниться в определении множества ('[chars]'),
            такая специальная последовательность, будет интерпретироваться
            как символ с восьмеричным кодом number.
\A          Удовлетворяет только началу строки.
\b          Удовлетворяет пустой строке в начале или конце слова.
            Слово определяется как последовательность из букв,
            цифр и символов подчеркивания. В определении множества
            ('[chars]') последовательность r'\b' для совместимости
            с литеральными выражениями Питон интерпретируется как
            символ возврата на одну позицию (BS)
\B          Удовлетворяет пустой строке в середине слова.
\d          Удовлетворяет любой десятичной цифре,
            эквивалентна множеству '0-9]'. При использовании флага LOCALE или
            UNICODE удовлетворяет символу, который в данном языке
            или базе данных Unicode считается десятичной цифрой.
\D          Удовлетворяет любому символу. не являющемуся десятичной цифрой,
            эквивалентна множеству '[^0-9]'.
            При использовании флага LOCALE или UNICODE
            удовлетворяет символу, который в данном языке или
            в базе данных Unicode не считается десятичной цифрой.
\s          Удовлетворяет любому символу пропуска, эквивалент
            множества r'[\t\n\v\f\r]'. При использовании флага LOCALE
            или UNICODE удовлетворяет символу, который в данном языке или
            в базе данных Unicode считается символом пропуска.
\S          Удовлетворяет любому символу, не являющемуся символом пропуска.
            Эквивалент r'[^\t\n\v\f\r]'. При использовании флага LOCALE
            или UNICODE удовлетворяет символу, который в данном языке или
            в базе данных Unicode не считается символом пропуска.
\w          Любой сивол, являющейся буквой, цифрой или подчерком.
            Эквивалент '[a-zA-Z0-9_]'
            При использовании флага LOCALE
            или UNICODE удовлетворяет символу подчерка, который в данном
            языке или в базе данных Unicode не считается символом пропуска.
\W          Удовлетворяет любому символу, не входящему в класс r'\w'
            эквивалент r'^\w'
\Z          Конец строки
\char       Символ char который без слеша является оператором регулярок.
"""



import re
#Две операции сопоставление match() и поиск search()
#re.match(pattern,string)
#re.search(pattern,string)
#Сопоставление дает истину только если строка соответствует регулярке
#с самого начала или с заданной позиции
print operator.truth(re.match('a','ba'))
#При поиске ^ в многострочном режиме MULTILINE кроме начала строки
#удовлетворяет позиции сразу после символа перехода на новую строку
print operator.truth(re.search('a','ba'))
robj=re.compile('.*^a',re.M) #флаги через |
print operator.truth(robj.match('\na'))
print operator.truth(robj.search('\na'))

#Разбивает строку на подстроки выдавая список этих подстрок по регулярке
print re.split('\W+','Words, words, words.')

#Возвращает список непересакающихся фрагметов строки по регулярке.
#Если регулярка содержит группы, элементами списка будут строки,
#удовлетворяющие группе, или кортеж строк, если групп в шаблоне несколько.
#Результаты сопоставления с нулевой длиной также включаются в результат.
print re.findall('\w+','Words, words, wor ds.')

#аналогично findall только с заменой на подстроку
#и возвращает строку
print re.sub('\w+','bla','Words, words, words.')

#точе что sub только возвращает кортеж из новой строки и числа замен
print re.subn('\w+','bla','Words, words, words.')

#Экранирует спецсиволы регулярки для нормального отбора
#хз как работает
rr=re.escape('\w+')
#rr='\w+'
print operator.truth(re.match(rr,'Words, words, words.'))

#Получение групп
#(?P<name>expr)
rez=re.match("(?P<grp1>[a-z]{0,}) (?P<grp2>[A-Z]{0,}) (?P<grp3>[123]{0,})","asd SDF 123")
print rez.group(1),rez.group(2),rez.group(3), rez.group()
print rez.groups()
#Возвращает словарь, отображающий имена групп к фрагментам, которым
#эти группы удовлетворяют
print rez.groupdict('noname')
#Возвращает номер символа в оригинальной строке откуда попалась
#последовательность удовлетворяющая регулярку выбравшей группу номер n
#rez.start(n)
print rez.start(2)

#span - Возвращает кортеж m.start(n_grp),m.end(n_grp)
#Кортеж позиций
print rez.span(2)
#Значение аргумента pos, endpos переданного методу search или match
print rez.pos
print rez.endpos
#Имя последней группы
print rez.lastgroup
#Индекс последней группы
print rez.lastindex
